---
title: Dropbox API使うときに必要だったGo言語のinterface変数をより具体的な型の変数として扱う手段
date: 2019-02-24T18:26:29+0900
tags:
- Go
categories:
- 開発メモ
author: jagijagijag1

status: public
created_at: 2019-02-24 18:26:29 +0900
updated_at: 2019-02-24 18:26:29 +0900
published_at: 2019-02-24 18:26:29 +0900
---
## 型アサーション = interface変数をより具体的な型の変数として扱う手段
- Go言語でinterface型の変数をダウンキャスト的に扱いたい場合は型アサーションが適用可能

```go
type Hoge interface {
  fuga() string
}

type Foo struct { }
func (f *Foo) fuga() string { return "fuga" }
func (f *Foo) piyo() string { return "piyo" }

func main() {
  h := Hoge(new(Foo))
  fmt.Println(h.fuga())

  original, ok := h.(*Foo)
  if ok {
    fmt.Println(original.piyo())
  }
}
```


## Dropbox APIで型アサーションが必要になったポイント
- Go言語ライブラリとして下記を利用
  - [GitHub - dropbox/dropbox-sdk-go-unofficial: An UNOFFICIAL Dropbox v2 API SDK for Go](https://github.com/dropbox/dropbox-sdk-go-unofficial)
- ListFolderで特定フォルダ配下のフォルダ・ファイル情報一覧を取得
  - [HTTP - Developers - Dropbox](https://www.dropbox.com/developers/documentation/http/documentation#files-list_folder)
- この際，フォルダ・ファイル情報は下記の形式で返ってくる

```go
type ListFolderResult struct {
	// Entries : The files and (direct) subfolders in the folder.
	Entries []IsMetadata `json:"entries"`
	// Cursor : Pass the cursor into `listFolderContinue` to see what's changed
	// in the folder since your previous query.
	Cursor string `json:"cursor"`
	// HasMore : If true, then there are more entries available. Pass the cursor
	// to `listFolderContinue` to retrieve the rest.
	HasMore bool `json:"has_more"`
}
```


- IsMetadataの実体がフォルダ(`FolderMetadata`)だったりファイル(`FileMeatadata`)だったりする
  - IsMetadataのデータを操作する場合はダウンキャスト的に具体的な型(subtype)として変数を扱う必要あり
  - この際，Go言語では上記型アサーションを使う
- 以下，Dropboxで特定フォルダ配下にあるファイル名のみを列挙する処理の例

```go
func main() {
	// initial setting
	token, path := <your-token>, <your-path>
	config := dropbox.Config{
		Token: dropboxToken,
	}
	dbx := files.New(config)

  // get info under the 'path' folder
	arg := files.NewListFolderArg(path)
	resp, err := dbx.ListFolder(arg)
	if err != nil {
		return -1
	}

  // for each result
	for _, e := range resp.Entries {
    // type cast to check e is file or not
		o, ok := e.(*files.FileMetadata)
		if ok {
      // if file, print the name of file
			fmt.Println(o.Name)
		}
	}

	return l 
}
```
