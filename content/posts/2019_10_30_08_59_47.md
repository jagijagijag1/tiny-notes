---
title: "基礎から学ぶVue.js 個人メモ"
date: 2019-10-30T08:59:47+0900
tags:
- Vue.js
categories:
- 読書メモ
author: jagijagijag1

status: public
created_at: 2019-10-30 08:59:47 +0900
updated_at: 2019-10-30 08:59:47 +0900
published_at: 2019-10-30 08:59:47 +0900
---
### p.46 `created`と`mounted`の使い分け
- `created`
  - リアクティブデータが初期化された直後に呼ばれる ＝ DOMは構築されてない
  - `this`にはアクセスできるが`$el`や`getElementById()`などでのDOMアクセスは負荷
- `mounted`
  - DOMが作成された直後
  - `$el`や`getElementById()`などを使用できる
  - すべての子コンポーネントがマウントされているかは保証しない


### p.48 Vue.jsのライフサイクル
![lifecycle.png](https://jp.vuejs.org/images/lifecycle.png)


### p.68 `v-if`と`v-show`の使い分け
- `v-if`
  - 条件を満たさない場合，DOMレベルで削除 = 監視解除
  - コンポーネントならインスタンスは破棄，次の描画時は初期化されている
  - 内側にディレクティブやコンポーネントを多用していたり，特定のデータを持っていないとエラーが起きる場合はこちらがよい
- `v-show`
  - 条件を満たさない場合，`display: none;`を付与 = 監視は継続
  - 内側にディレクティブやコンポーネントが少なく，切り替えの頻度が高い場合はこちらの方がパフォーマンスよい


### p.70 リストデータの扱い
- リストデータ：オブジェクトを要素にした配列にするとよい (単なる文字列の配列でなく)
  - プロパティにユニークキーをもたせることで，更新するとき仮想DOMによる描画最適化が行われるため
    - 効率的な描画のため，ユニークな`key`属性を設定することが強く推奨されている
    - VSCodeでもデフォルトのLinterでエラー扱いになる
  - e.g. `<li v-for="item in list" v-bind:key="item.id">`
    - ↑の`v-bind:key`のところを指定すると描画最適化される

### p.102 コンポーネントのイベントハンドリング
- `.native`修飾子をつけるとコンポーネントのイベントを受けてハンドラ実行できる
```html
<!-- コンポーネントをクリックするとハンドラが呼び出される -->
<my-component v-on:click.native="handler" />
<!-- コンポーネントをクリックしてもハンドラが呼び出されない -->
<my-component v-on:click="handler" />
```

### p.113 フォーム入力の修飾子
- `.lazy`をつけると`change`イベントで同期
  - テキストフォームの場合，フォーカスが外れたりエンターを押したときに同期
  - デフォルト(`.lazy`なし)の場合は入力された時点で同期

### p.123 算出プロパティのキャッシュ
- キャッシュを再構築するトリガになるのはリアクティブなデータのみ
- 算出プロパティで使う`Math.random()`はリアクティブでないため，何度使用しても同じ数字が返される

### p.209 リストトランジッション LeaveとMoveの同時発生
- 絞り込みなどで複数要素が同時に消えるとき，後ろのようsはLeaveとMoveの両方のクラスがつく
- このときCSSで両方が適用され，どちらかの設定がどちらかで上書きされる
- これを回避するためには`:not()`をつかう
```css
.v-enter-active .v-leave-active {
  transition: opacity 1s, transform 1s;
}
.v-move:not(.v-leave-active) {
  transition: transform 1s;
}
```

### p.248 スプレッド演算子
- 配列やオブジェクトのリテラルを展開する
- 複数のオブジェクトを一つにまとめることもできる

```js
const array = [1, 2, 3]

// バラバラの3つの引数として渡す
myFunction(..array)

// arrayを展開して4を加えた新しい一次元配列を作成
const newArray = [..array, 4] // -> (4)[1, 2, 3, 4]
```


### p.258 Vuexのコアコンセプト
![vuex.png](https://vuex.vuejs.org/vuex.png)

### p.271 Vuex ミューテーション
- 下記コードで`store.commit('update')`するとA, B両方のupdateが実行される
  - これに対し，各moduleの定義で`namespaced: true`にすることで，`commit('moduleA/update')`のように個別アクセスできるようになる

```js
const moduleA = {
  state: {
    count: 1
  },
  mutations: {
    update(state) { state.count += 100 }
  }
}

const moduleB = {
  state: {
    count: 2
  },
  mutations: {
    update(state) { state.count += 200 }
  }
}
```

### p.279 Vuex Strictモード
- Strictモードを使うと，タイプミスなどで不用意にステートを変更すると警告が出るようになる
  - 本番・運用では不要なので，環境変数で切り替えるようにするとよい

  ```js
  const store = new Vuex.Store({
    strict: process.env.NODE_ENV !== 'production'
  })
  ```
  

### p.313
- ページ遷移のエフェクトをつける一連のコード

```js
// ルータービュー用のVuexモジュール
export default {
  namespaced: true,
  state: {
    loading: false
  },
  mutations: {
    start(state) { state.loading = true },
    end(state) { state.loading = false}
  }
}
```

```js
// グローバルのナビゲーションガード
router.beforeEach((to, from, next) => {
  store.commit('view/start')
  next()
})
router.afterEach(() => {
  state.commit('view/end')
})
```

```html
<!-- オーバーレイ用のコンポーネント -->
<template>
  <transition name="loading">
    <div class="loading" v-if="loading">Loading</div>
  </transition>
</template>

<script>
export default {
  computed() {
    loading() { return this.$store.state.view.loading $}
  }
}
</script>
```

```css
.loading-enter-active {
  transition: all 0.25s;
}
.loading-leave-active {
  transition: all 0.5s ease 0.5s;
}
```


### p.316 コンポーネントの非同期読み込み
- webpackのコード分割機能をつかって，必要になった時点でJavaScriptファイルを読み込むことができる
```js
const About = () => import('@/views/About')
const router = new VueRouter({
  routes: [
    {
      path: '/about',
      component: About
      // component: () => import('@/vue/About') でもOK
    }
  ]
})
```
  
  
### p.317 Vue Router ルートアクセス制限
- 認証を確認したいルートの定義: まずメタ情報をもたせる
```js
{
  path: '/user',
  component: User,
  meta: { requiresAuth: true }
}
```

- その後，グローバルなルート制御で認証チェックする処理を入れる
```js
router.beforeEach((to, from, next) => {
  // 上位ルートを含めて人所グア必要なルートがあるかを確認
  if (to.matched.some(record => record.meta.requireAuth)) {
    // 認証状態を確認
    if (!auth.loggedIn()) {
      // 認証していなければログインページにリダイレクト
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 認証確認不要なルートなら普通に遷移
  }
})
```
