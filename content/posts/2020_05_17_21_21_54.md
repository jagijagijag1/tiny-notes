---
title: プログラミング言語Go完全入門
date: 2020-05-17T21:21:54+0900
tags:
- Go
categories:
- 開発メモ
author: jagijagijag1

status: public
created_at: 2020-05-17 21:21:54 +0900
updated_at: 2020-06-18 07:08:03 +0900
published_at: 2020-05-17 21:21:54 +0900
---
## 1. Goに触れる
- Goの特徴
  - シンプルで協力な記述
    - 機能を増やすことで言語を拡張していくことはしない
  - 並行プログラミング
    - マルチコア前提，並行処理とガーベッジコレクション
    - goroutine: 軽量スレッド的なもの，`go`キーワードをつけるだけ，e.g. `go f()`で関数を並行呼び出し
  - 必要なライブラリやツールが標準で同梱されてる
  - シングルバイナリ・クロスコンパイル
    - コマンドラインツールの開発に向いてる
    - 組み込み・IoTにも (TinyGoという組み込み向けのサブセットもある)
    - フロントエンド向け，wasm以外にもGopherJSというのもある
  - 静的解析しやすい言語
- Goのバージョン
  - Go1の間は後方互換
  - Go2＝Go1.xを拡張していって，後方互換が保てなくなる場合にGo2にするというポリシ
- 重要そうな技術
  - gRPC
  - gVisor
- 学習ソース
  - [go.dev](https://go.dev/)
  - [Go Codereview Comments](https://knsh14.github.io/translations/go-codereview-comments/)
    - Goらしい書き方

## 2. 基本構文
- 数値をアンダースコアで区切れる
  - e.g. `5_000_000`
- 連続整数を`iota`で定義できる
  ```go
  const (
		a = iota
		b
		c
	)
	fmt.Printf("%d, %d, %d", a, b, c) // -> 1, 2, 3
  ```

## 3. 関数と型
- 少し特殊な配列定義方法
```go
	array1 := [...]int{1, 2, 3}
	fmt.Println(array1) // [1 2 3]

	array2 := [...]int{5: 50, 10: 100}
	fmt.Println(array2) // [0 0 0 0 0 50 0 0 0 0 10]
```

- arrayとslice
  - arrayは固定長，静的
  - sliceは参照型，可変長，動的
    - sliceの容量はメモリ確保済みのサイズなので拡張可能
    - 容量オーバーしたら基本的に２倍の値を確保

- slice trick
```go
	// slice tricks: cut
	aa := []int{1, 2, 3, 4, 5}
	fmt.Println(aa) // [1, 2, 3, 4, 5]
	aa = append(aa[:2], aa[3:]...)
	fmt.Println(aa) // [1, 2, 4, 5]
```

## 4. パッケージ
- go get => dep => modules (vgo)
- modulesを使う
  - `go mod init` でgo.modを生成
  - main作成
    ```go
    package main
    
    import (
    	"fmt"
    
    	"github.com/tenntenn/greeting"
    )
    
    func main() {
    	fmt.Println(greeting.Do())
    }
    ```
  - `go run xxx.go` するとgo.modにパッケージ追記されて実行できる
    - runする前に`go mod tidy`してもOK
    - vendorディレクトリ配下にパッケージダウンロードするときは`go mod vendor`
  - 後方互換のないバージョン使う場合はimport時の記述を変える
    ```go
    package main
    
    import (
    	"fmt"
      "time"
    
    	"github.com/tenntenn/greeting/v2"
    )
    
    func main() {
      fmt.Println(greeting.Do(time.Now()))
    }
    ```
    
 ## 5. コマンドラインツール
 - forでファイル処理したいとき→forの中でdeferせず処理を関数化して関数の方でdeferする
  - NG
    ```go
    for _, fn := range fileNames {
      f, err := os.Open(fn)
      if err != nil {
        // エラー処理
      }
      defer f.Close() // fを使った処理
    }
     ```
  - OK
     ```go
     for _, fn := range fileNames {
       err := readFile(fn)
       if err != nil { /* エラー処理 */ }
     }
     ```
     ```go      
     func readFile(fn string) error {
       f, err := os.Open(fn)
       if err != nil { return err }
         // fを使った処理
       defer f.Close()
     }
     ```

 ## 6. 抽象化
 - 型スイッチ
```go      
	// type switch
	var i interface{}
	i = 100
	switch v := i.(type) {
	case int:
		fmt.Println(v * 2)
	case string:
		fmt.Println(v + "hoge")
	default:
		fmt.Println("default")
	} 
```

## 8. テストとテスタビリティ
- `Example`で始まる関数名のテストを書くとGoDocにサンプルとして出力される


- テーブル駆動テスト + サブテスト
```go
func TestIsOdd(t *testing.T) {
  cases := []struct {name string; input int; expected bool}{
    {name: "+odd", input: 5, expected: true},
    {name: "+even", input: 6, expected: false},
    {name: "-odd", input: -5, expected: true},
    {name: "-even", input: -6, expected: false},
    {name: "zero", input: 0, expected: false},
  }
  
  for _, c := range cases {
    c := c
    t.Run(c.name, func(t *testing.T) {
      if actual := IsOdd(c.input); c.expected != actual {
        t.Errorf(
          "want IsOdd(%d) = %v, got %v",
          c.input, c.expected, actual)
      }
    })
  }
}
```


- テストデータは`testdata`というディレクトリに入れる
  - パッケージとして認識されなくなる


## 9. ゴールーチンとチャネル
- goroutineが切り替わるタイミング
  - (ブロックされる)チャネルへの読み書き
  - 待ちが発生するシステムコール
  - `time.Sleep`
  - メモリ割り当て
  - `runtime.Gosched`
- チャネルをcloseすると受信場所にゼロ値が送られる＝ブロードキャスト，処理終了通知として使われる

